// Generated by CoffeeScript 1.3.1

/*
 Simply Deferred - v.1.3.2
 (c) 2012 Sudhir Jonathan, contact.me@sudhirjonathan.com, MIT Licensed.
 Portions of this code are inspired and borrowed from Underscore.js (http://underscorejs.org/) (MIT License)
 */


(function(rpc) {
    var Deferred, PENDING, REJECTED, RESOLVED, after, execute, flatten, has, isArguments, wrap, _when,
        __slice = [].slice;

    PENDING = "pending";

    RESOLVED = "resolved";

    REJECTED = "rejected";

    has = function(obj, prop) {
        return obj !== null ? obj.hasOwnProperty(prop) : void 0;
    };

    isArguments = function(obj) {
        return has(obj, 'length') && has(obj, 'callee');
    };

    flatten = function(array) {
        if (isArguments(array)) {
            return flatten(Array.prototype.slice.call(array));
        }
        if (!Array.isArray(array)) {
            return [array];
        }
        return array.reduce(function(memo, value) {
            if (Array.isArray(value)) {
                return memo.concat(flatten(value));
            }
            memo.push(value);
            return memo;
        }, []);
    };

    after = function(times, func) {
        if (times <= 0) {
            return func();
        }
        return function() {
            if (--times < 1) {
                return func.apply(this, arguments);
            }
        };
    };

    wrap = function(func, wrapper) {
        return function() {
            var args;
            args = [func].concat(Array.prototype.slice.call(arguments, 0));
            return wrapper.apply(this, args);
        };
    };

    execute = function(callbacks, args, context) {
        var callback, _i, _len, _ref, _results;
        _ref = flatten(callbacks);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            callback = _ref[_i];
            _results.push(callback.call.apply(callback, [context].concat(__slice.call(args))));
        }
        return _results;
    };

    Deferred = function() {
        var alwaysCallbacks, close, closingArguments, doneCallbacks, failCallbacks, state;
        state = PENDING;
        doneCallbacks = [];
        failCallbacks = [];
        alwaysCallbacks = [];
        closingArguments = {};
        this.promise = function(candidate) {
            var pipe, storeCallbacks;
            candidate = candidate || {};
            candidate.state = function() {
                return state;
            };
            storeCallbacks = function(shouldExecuteImmediately, holder) {
                return function() {
                    if (state === PENDING) {
                        holder.push.apply(holder, flatten(arguments));
                    }
                    if (shouldExecuteImmediately()) {
                        execute(arguments, closingArguments);
                    }
                    return candidate;
                };
            };
            pipe = function(doneFilter, failFilter) {
                var deferred, filter;
                deferred = new Deferred();
                filter = function(target, source, filter) {
                    if (filter) {
                        return target(function() {
                            return source(filter.apply(null, arguments));
                        });
                    } else {
                        return target(function() {
                            return source.apply(null, arguments);
                        });
                    }
                };
                filter(candidate.done, deferred.resolve, doneFilter);
                filter(candidate.fail, deferred.reject, failFilter);
                return deferred;
            };
            candidate.done = storeCallbacks((function() {
                return state === RESOLVED;
            }), doneCallbacks);
            candidate.fail = storeCallbacks((function() {
                return state === REJECTED;
            }), failCallbacks);
            candidate.always = storeCallbacks((function() {
                return state !== PENDING;
            }), alwaysCallbacks);
            candidate.pipe = pipe;
            candidate.then = pipe;
            return candidate;
        };
        this.promise(this);
        close = function(finalState, callbacks, context) {
            return function() {
                if (state === PENDING) {
                    state = finalState;
                    closingArguments = arguments;
                    execute([callbacks, alwaysCallbacks], closingArguments, context);
                }
                return this;
            };
        };
        this.resolve = close(RESOLVED, doneCallbacks);
        this.reject = close(REJECTED, failCallbacks);
        this.resolveWith = function() {
            var args, context;
            context = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            return close(RESOLVED, doneCallbacks, context).apply(null, args);
        };
        this.rejectWith = function() {
            var args, context;
            context = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            return close(REJECTED, failCallbacks, context).apply(null, args);
        };
        return this;
    };

    _when = function() {
        var def, defs, finish, errfn, trigger, _i, _j, _len, _len1;
        trigger = new Deferred();
        defs = flatten(arguments);
        finish = after(defs.length, trigger.resolve);
        for (_i = 0, _len = defs.length; _i < _len; _i++) {
            def = defs[_i];
            def.done(finish);
        }
        errfn = function() {
            return trigger.reject();
        };
        for (_j = 0, _len1 = defs.length; _j < _len1; _j++) {
            def = defs[_j];
            def.fail(errfn);
        }
        return trigger.promise();
    };

    rpc.defer = function() {
        return new Deferred();
    };
    rpc.defer.when = _when;

})(rpc);